picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTIzIDIzOjQxOjA4Iixtb2RpZmllZD0iMjAyNS0x
MC0yNCAwMjowODowNiIscmV2aXNpb249MTU2XV1sejQAnQUAAFg6AADzIXtbMF09e2JtcD1weHUA
QyAQEATwVgcQB8AX0BfABxAH8FYsZmxhZ3M9MCxwYW5feAgAyHk9MCx6b29tPTh9LD4A8DoYBC4x
DiwRbjE8AU5RTF4xXG4MEWxenG5sjnyObH5sfmwNfmwNbnwdXhwOTB1OjC0_jC1OjA1eHWxeLWxe
HTwOLE4tLB4sTh08BQCPTA5MXjwOTB6CABwZPoIAIGxeggBPfI58foIABv8XPg1sLU49PB1OXSwN
Xl08Ti0OPSwOHB4dHi0OXB4dHj0OTG4tDjyHABrwDRgHBBj_BBgC_AYCDvIGPhYlfiUWTgcFBgcG
ngYHAN8_BwYXvgcGF04X3hcuWQALGTVZAGcqHQQOCAkCAFew-gEJCAIAOLAICQIAGxguACkJCAIA
PxgJCDwAB2AIGQgJCIk0AB_pKgAPMbmw6SMAEmkdABJpGQCEBwkHiQcJB5AJAOAJCLkHCJAHCAeZ
CAcIFxYANEkHCSEAAw0AYBcOBwkHaQoAM5AHCQsAIQgeLQABAgA0J5BXCgA2HgcJAgBnJ3DXCQcJ
KQAwN3DHCAAJJQBCBwkHcAcAGYksAEZHUAkHAgB5KQcJBy4JBwIAM1AHCQIAYnk_9wAwZwwAagkH
KT4JBwIANDAJBwIAYnlO9wAQdwwAggkHGV4HCfcFDABiCQdJbvcLCgAmCY4WAEEprvcJCgAzzvcD
EgBA-gD3BAkAU-4EpwkHAgBf-gnHCd45Ahn-HiAOBD5n-gen-gTX-gL3AO73A873Ba73CF73EB73
DE73Cm73B673A_7X-gWH3usCGWMXFQT_BggDACMFGAMARQQo-gQMAAEPABcDAwD-AAI4-gE4-gBI
zij_Aij_BG8AGfAdVjoE-hrwCv4l8Bf_G-Ag-hLwKP4L8C7_BfAx-gLwNO7wNt7wOL7wOp7wPI4D
AFM9foABAAIAj-ArfvA_bgABAgALj-AebvA-XgABAgATj-AXbvA-jgABAgAVj-ASnvA7ngEAAgAa
r-AMrkAB8DO_AAECAB1b8AbeAQACAL-wJf4AAAEA8QUAAQIAB1-wAv4AAQIAB5-wG_4BAPEPAAEC
AANP0O4AAQIADSDwFUMAPxMAAT8AIwACAIzwEP4A8RkAAQIAEaDhAAgCAD9hAAFXAQFq7gDxHQAB
AgAjgO4JAFoA8QcAAQIAhvAH-gDxIgABAgAWcCcBTPEJAAECAIbwA-4A8SQAAQIANUD_ATEAPQsA
AXYBGgFgAA8xAAyaAAHg-gLxIAABAgA-MP4CNAAJPtD_AzQAPyD_AzQACXzA-gTxHgABAgAzEP4E
CgAPUwIIf7D_BfEcAAECAABG-gUBAAIAP_EAAQIABT_g-gfqAQEAAgAd-qcBDwIAD3_w-gjxFwAB
AgABT-4KAQACABw-kP4MyQIDbwAB-hABAAIAFn6A-hbxCgABAgBP-h4BAAIADG0w-ilRAAECAC-_
FV4FCzszfSz-CR-wMQD-------------qv8VCAgECG4CCF4BAghOAAECCD4QAQIILiABAggeMAEC
CA5AAQIIZhAZ-xUICARuCF4IAk4IAgE_CAIBAC4IAgEQHggCASAOCAIBMAgCAUBQABxQjv0AAQ0C
ACIRDQgAA6ELEhEIAB_ATwAdQPgAAggCACISCAgAIQECAgASEggAH4FPABwv-jAxAK9F8AFnAAIA
DzwAHTYAVxACAA89ABxvAgFQAfAnNQAcf1ABAmAB8CBGAR4PMQCvAqEBD6sBJgKjAQ_tASaf8A8H
QCcgRwDnOAAcf1AXMDcQ9x5OAR4PMQCvH-AxAB0SYGIBj2cAVxA3MBfAPgAcAjYAL-AdNwAcI-AX
dgAPQAEeDzEA--------0g5NDQ8xAP-------------------------------2NQbT04fX0=
:: gfx/fixed.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNS0x
MC0yMyAyMzozMjoyMyIscmV2aXNpb249OF1dbHo0AEEHAAAbOgAA8yF7WzBdPXtibXA9cHh1AEMg
CAgE8AIHEAdAF1AXQAcQB-ACLGZsYWdzPTAscGFuX3gIAMp5PTAsem9vbT03fSw_ADEOCAkCABIO
BwATCRAAERgGAHQIGQgJCDkIDAARWQgAHyliABwRCTYAERAGACoJEA4AFUkKAG9ZEDkICRBbABwv
8DAxABwvEF6IAAM2CQg5iQAP5AAgJn4IMAEGPgETeQgAEMkGAA9SAB15GF4JCF4ICQYAD0QAHJ8_
Nx5XDmcO9xc4AByPJ05HLmcO9xg3ABxA-ggHbjsAL-cAOQAdPyZ3HjMAHR8wMQBNgF4IbghuCF4Y
AgBPTihOGKIAHVCO-QABDQIAIhENCAAhAAECABIRCAAfgPEAfvAEBwkHSQhpBwkHCQcpDgcJBzkO
FwwAMQkOBwcAGwcPAA9eAByhOQcJBwBJBwgAGT4AIAApBwAQAAUAICcAEQAjCTcEAA5dAA8IBEAB
cwBiKQAHCAc5fgADjABjBxkAVwn3EwAfGVUAHFBZB2kIB_gAMlkHCSwBf3cJVwkHeQeJAR6xXggH
XhdeCG4HbgkEAA9BABy-dw5nHlc_N14X-gg6ABxf9xgOZ-6-Ax2P9w8ONz4X-gY3ABx-Nz4nTgf_
HwgDTiAfCMEDDzYAHP8APhhOGE4oPig_KE4YXgjuPgAcbwIBUAHwJzUAHH9QAQJgAfAgEAFNA8cD
ER4GADMHHlcJAK8uRy4HCSc_N04nNwQfBbgDE4cIAC-3EUUAHe9QGVAnMBcJBzAJNxD3C4MAIACw
AwIIABhXCgAFiQMfF1kEIgAmBCEHiToAEakGAHQZDgkHSQ4HQwEvKS5RAB0v-i-cBE3-EQhuAghe
AQIITgABAgg_EAECCC4gAQIIHjABAggOQAECFAQd-xJuCF4IAk4IAgE_CAIBAC4IAgEQHggCASAO
CAIBMAgCAUDCA06PBwgeKC4o-g04AByPLjgeOC4o-h2gAE2f8A8HQCcgRwDnOAAcb1AXMDcQ9-oI
Tl9eF24H-lcEHW-3AA5nLkdCBiE-DgmHNQAeO2cJF7sDXw4nCf4MBwQgLz4pVAZRQfAJZwACAB9w
OQAdNQFnAAIADzwAHTYAVxACAA89ABwCcgAPfAAmAnQAD34AJlCO_AACCAIAIhIICAAhAQICABIS
CAAfgU8AHBJgcAOPZwBXEDcwF8A_ABwCNgAf8BcEHSPwF3YAD10CTS-_L0ANHk8dIB7QNAAdXwcA
LvAVNQAcP67wJTIAHD8e8C7wBk0PMQAePzA_8A8KHW9_EF5gDvARDx9AIE5QHgIAH0AGAR3-BC4x
TjEeUS4xDD4MEQw_PE4sTixCABz-AiwRLjwBLkwuTC5cHlwePD5MgwBrAAYAD4MAHg88Ax9wFwBe
EE4gPmIPDzsAHJFOIC5ADvAOAYCfDw8-AB4j8Bk4AA9AACUfKTgAKB8wZAMdDzEA4SBALgIAnzA_
MD4gTiBOEE0THf8DXhxOLD48PjwuTC4cDhweXB5cQQAcYUwuPD4sDQMAIB0uAwAgLR4DAA_GAKEP
mAMeMi5AHt4CIR5QnAMxPjAuDwAFGAAP9gIcG4BtAwMIAD8RcAFPADkvAYBPAMMR4DcAEaAGAB8A
8QQoH_B7BINvFw5QHjA_4QMeXxBeAG4APAwewS5MLh0sHi0sHh08DgYAXx4dTD48RQAcQjwNLjxi
B29OLE5MLkyQAx3-CB4NTB49HA5dDA5dDC0OXR4tDh0ePU4tRgAcgBwtLhwdPhwNhgAAXARPLkwu
PLIHThIefgIABwQTIQwAbw4BAEEOAAwAAB9hXAAcAjcAPwEAgQgABB9xUAAfH0BMADUmcBEOGB8g
TQAtBMMDBlUAIkBRWwAPTQAoDAgAL3ARbwQkDm0ED3UEJz8JAeB3BCNPJw5gDswCTQ8xAB7-Bxhe
AmgOYi4WJR4HBQYHBi4HBhdOF65FABxvfnhybgX_kw8dwE4YDlgCDlIeFRY_Bn0AET58AB__IwF_
A-0DKxBxIwMPxAMoAQIAH-EDDh0eYTMAD2wAFU-hAPEYOwAkDO8AH6H1ACUHEQQPQwEtD24EABMx
CAAPIwQvH6AhBCtEYA5gDnMPAAIAD9ACHg8xAP9DHwF6AgQPggIlT-EhANEzAB0PtAAdL-EnlwAe
FyGjAx6h4QAPMQEwBsUDHjEdAw9WABMkMAG2Aw8MAA4fARkEJA4IAA9PACIGqw8BmwsfbtcCHg8x
AP9DFQGOCwaYCwO5C28uQV4BAH5QACARwT8ADu8CLx5RTQAcEvE4AA9iBC8fIUYAAg-PA4AEswMD
BgA-ARABDgALD2gAJQYfBB1QCgAPdhEsE2BJAjAeQC4HAD8_EN71Ah4PMQD-1iIBAAIAH-6LCyVf
UQAB-iA8ACMEPgMPQABfXzAuAP4njAEeDzEA-6WfEA8QDw8PIfArWRUeDzEA-------------3wf
-pMAHg8xAP8xUG09N319
:: gfx/raw.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTIzIDIzOjIxOjM3Iixtb2RpZmllZD0iMjAyNS0x
MC0yNCAwMDoyMzoxMCIscmV2aXNpb249MzJdXWx6NAAgBwAADDoAAPMhe1swXT17Ym1wPXB4dQBD
IAgIBPACBxAHQBdQF0AHEAfwAixmbGFncz0wLHBhbl94CADKeT0wLHpvb209N30sPgAxDggJAgAS
DgcAEwkQABEYBgB0CBkICQg5CAwAEVkIAB8pYgAcEQk2ABEQBgAqCRAOABVJCgBvWRA5CAkQWwAc
L-AwMQAcLxBeiAADNgkIOYkAD_QAICZ_CDABBj4BE3kIABDJBgAPUgAdeRheCQheCAkGAA9EABwv
-jAxAE3wBAcJB0kIaQcJBwkHKQ4HCQc5DhcMADEJDgcHABsHDwAPXgAcoTkHCQcASQcIABk_ACAA
KQcAEAAFACAnABEAIwk3BAAOXQAPPAJAAXMAYikABwgHOX4AA4wAYwcZAFcJ9xMAHxlVABxQWQdp
CAfoADJZBwksAX93CVcJB3kHiQEesV4IB14XXghuB24JBAAPLAJ_AwwCER4GADMHHlcJAK8uRy4H
CSc_N04nfAIfBf0BE4cIAC-3EUUAHe9QGVAnMBcJBzAJNxD3C4MAIAD1AQIIABhXCgAFzgEfF54C
IgBrAiEHiToAEakGAHQZDgkHSQ4HQwEvKS5RAB0v-i8SAn5vXhduB-4gNQAcr-cADmcuR14X-gg5
AB0-DgmHNQAeO2cJF9wBXw4nCf4MKAIgbz4pTgf_HzkAHIBeCG4IbgheGAIAX04oThgekwFNnz43
HlcOZw73FzgAHI8nTkcuZw73GDcAHED_CAduOwAv9wA5AB0vJncMAU4w-h8IdgEPNgAc-wA_GE4Y
Tig_KD4oThheCO6lAE1-dw5nHlc_NxADIU8YDmf_eAEdj-cPDjc_F-4GNwAcPzc_J-4CIJ-_Bwge
KC4o-g04AByPLjgeOC4o-h0hAh4PMQD---9g-xEIbgIIXgECCE4AAQIIPhABAgguIAECCB4wAQII
DkABAtMEHf8SbgheCAJOCAIBPggCAQAuCAIBEB4IAgEgDggCATAIAgFAUAAcUI79AAENAgAiEQ0I
ACEAAQIAEhEIAB_ATwAdQPgAAggCACISCAgAIQECAgASEggAH4FPABz-BC4xTjEeUS4xDD4MEQw_
PE4sTixCABz-AywRLjwBLkwuTC5cHlwePD5MLoMAagAGAA_DAB5F8AFnAAIADzwAHTYAVxACAA89
ABxfAgFQAfC1DB1vUAECYAHw9Aod-wNeHE4sPjw_PC5MLhwOHB5cHlxBABxhTC48PiwNAwAgHS4D
ACAtHgMAD4YAoQLpAQ-zASYC6wEP9QEmn-APB0AnIEcA5zgAHG9QFzA3EPfsAB3BLkwuHSweLSwe
HTwOBgBfHh1MPjxFABxCPA0uPJsDb04sTkwuTIUAHf8IHg1MHj0cDl0MDl0MLQ5dHi0OHR49Ti1G
AByAHC0uHB0_HA2GAAA9Al8uTC48LrMRTRJgrQGPZwBXEDcwF8A_ABwCNgAf8EcKHSPwF3YAD5oC
HP8HGF4CaA5iLhYlHgcFBgcGLgcGF04XrkUAHG9_eHJuBf7WAh3AThgOWAIOUh4VFj4GfQARPnwA
H74wCB4PMQD-------90Hy9IFB5PHSAe0DQAHV8HAC7wFTUAHD_u8CUyABwvHvAgCU4PMQAegP4X
AF4QTiA_-g4POwAckU4gLkAO8A4BgDsPDz8AHiPwGTgAD0AAJR8pOAAoD1gBHg8xAH8yLkAeAAEh
HlC_ATE_MC4PAAUYAA8YARwbgI8BAwgAPxFwAU8AOS8BgE8AwxHgNwARoAYAHwATAygf4J0CURIe
nwAAKAITIQwAbw4BAEEOAAwAAB9hXAAcAjcAPwEAgQgABB9xUAAfH0BMADUmcBHtEx8gTQAtBOQB
BlUAIkBRWwAPTQAoDAgAL3ARkAIkDo4CD5YCJz8JAeCYAiIDRAIrEHFqAQ8LAigBAgAf8cIbHR5h
MwAPbAAVT_EA8Rg7ACQM7wAfofUAJQdYAg9DAS0PtQIAEzEIAA9qAi8McAIPOAE0D_wAJU-xIQDR
MwAdD_MCHS-xJ5cAHhchDQIeoeEADzEBMAYvAh8xhwElJDABIAIPDAAOHwGDAiQPCAABD68AJQGp
BgazBgPUBm8uQV4BAH5QACARwT8ADlkBLx5RTQAcEvE4AA-MAi8fIUYAAg85AoAEHQIDBgA-ARAB
DgAID-IBKAaJAh1QCgAPsgosE2BJAjAeQC4HAD8_EN4XD34iAQACAB-_1wYlX1EAAf4gPAAjBLYB
D0AAX18wLgD_J1sBTT8wPvBVAR1vfhBeYA7wKiUfQCBOUB4CAC9ALtUAHg8xAOAf8DEATiBALgIA
nzA_MD4gTiBOEJ0tHw_WAf8TbxcOUB4wPl4BHl8QXgBuAHEmHx8wlAHhTycOYA5lAB4PMQD-Q0Rg
DmAO5QUvQC7pBSAPMQD-QwbjBQFWBA9aMR8PMQD-----Q1BtPTd9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTEyIDE0OjQ5OjMwIixtb2RpZmllZD0iMjAyNS0x
MC0yNSAwMjowMjoxMCJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNS0x
MC0yMyAyMzoxNzoyNSIscmV2aXNpb249M11dbHo0ACkBAADmAQAA8BF7e2JtcD1weHUATICAQAAF
CwABNgAAKQAAKAAFNgBvABIAEgASAEAeAAAfGAAVBBgAARUAIwEnGAB0CzYAZwAABBgAUwI3AAA9
GwARChsAFAMbABQFMwARCRgAFQIYAAIzAAQeABEIHgAUAR4AUwgnAAA-GwARBxsAFQAbAAI5ABY_
PAASBiEAAR4AEgs5AASNABIFGwA0HgALNgAmASfbAEVnAAAOMAAEigARAxgAFA0wABQCGAARAhgA
AD8AZDgAADkADxgAFQEYAGQ6AAA7ABAYABoAGAAUERgAr2cAABcOAP8AAP8BAAPxCn8saGlkZGVu
PWZhbHNlLHBhbl94PS0xODgLAOJ5PS0xMCx0aWxlX2g9OAkA4Hc9OCx6b29tPTAuNX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTEyIDE0OjQ5OjMwIixtb2RpZmllZD0iMjAyNS0x
MC0yNSAwMjowMjoxMCJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA3LTMxIDA4OjMwOjI4Iixtb2RpZmllZD0iMjAyNS0w
Ny0zMSAwODozMDoyOCIscmV2aXNpb249MF1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oBEAYP
MBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA------_9
H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTEyIDE0OjQ5OjMwIixtb2RpZmllZD0iMjAyNS0x
MC0yNSAwMjowMjoxMCJdXQ==
:: etc.lua
--[[pod_format="raw",created="2025-10-23 22:34:30",modified="2025-10-23 22:50:31",revision=10,xstickers={}]]
-- fps - fish person shooter
-- happy birthday, kovie!









-- FUNCTIONS
--Draw start screen

:: intro.lua
--[[pod_format="raw",created="2025-10-23 22:34:26",modified="2025-10-24 07:44:52",revision=24,xstickers={}]]
-- Intro after starting game

--return frame number given a counter, initial frame, width of frames and duration of each frame (30 = 1s)
function incFrame(counter, frame, width, duration)
    return frame + (width * (flr((width / duration) * (counter % duration))))
end

-- Draw gradients for horizon
function drawHorizon(offset, startI, endJ, _color)
    -- Fills follow a 4x4 map. example of the first one:
    -- 1111
    -- 0101
    -- 1111
    -- 0101
    fills = {0b1111010111110101, 0b0101101001011010, 0b0101000001010000}

    i = startI
    j = endJ

    height = (startI - endJ) / 3

    for k=1,3 do
        fillp(flr(fills[k]))
        rectfill(0, i + flr(offset), 128, j + flr(offset), _color)
        i -= height
        j -= height
    end

    fillp(0)
end

-- Draw a single building (just a rectangle)
function drawBuilding(x, y, xOffset, yOffset, width, height, color)
    rectfill(((x + xOffset) % (128 + width)) - width, (y + yOffset) - height, (0 + xOffset) % (128 + width), y + yOffset, color)
end

-- Draw a horizon and multiple buildings
function drawBuildings(y, xOffset, yOffset, _color)
    rectfill(0, (y + yOffset % 128), 480, 270, _color)
    drawBuilding(0, y, xOffset, yOffset, 28, 64, _color)
    drawBuilding(0, y, xOffset + 32, yOffset, 28, 48, _color)
    drawBuilding(0, y, xOffset + 64, yOffset, 28, 56, _color)
    drawBuilding(0, y, xOffset + 96, yOffset, 28, 48, _color)
    drawBuilding(0, y, xOffset + 126, yOffset, 28, 56, _color)
end

-- Intro animation structure
function introAnim()
    escapeCounter += 1
    if(escapeCounter < 800) then
       xOffset = -5*bobble(0, escapeCounter, 100, 500, 0, 0.25)
       animCount1 = bobble(24, escapeCounter, 100, 40, 0.5, 1.25)
    end
    
    if(yOffset < 24) then
        animCount += 1
        if(animCount < 80*2) then
            yOffset = -bobble(0, animCount, 20, 500, 0, 0.25)
        end
    end

    -- Background color white
    rectfill(0,0,480,270,1)
    -- Dynamic horizon shapes
    rectfill(0, 112 + flr(-yOffset / 4), 480, 270, 0)
    drawHorizon(yOffset / -4, 124, 80, 0x8e)
    drawHorizon(yOffset / -4, 80, 56, 0xe2)
    drawHorizon(yOffset / -4, 56, 22, 0x21)
    drawBuildings(100, xOffset / 4, yOffset / -4, 0)
    -- Entry building
    map(0, 0, 0 + xOffset, 0, 24, 16)

    for i=0,17 do
        pal(7, 7)
        spr(60, (((i * 8) + xOffset) % 136) - 8, 120 - yOffset, 1, 1)
    end

    sspr(incFrame(escapeCounter, 1, 2, 180), 0, 0, 16, 24, animCount1, 90 - yOffset, 16 * 2, 24 * 2)
    spr(123, animCount1 - 3, 113 - yOffset, 3, 1)

    if(xOffset == 0) then
        screenID = 3
    end
end

function menuSelect()
    if(btn(5)) then
        screenID = 3
    end
    if(mode == 1) then
        introAnim()
    end
end
:: main.lua
--[[pod_format="raw",created="2025-10-23 22:32:52",modified="2025-10-24 23:19:21",revision=42,xstickers={}]]
include("start.lua")
include("intro.lua")
include("procgen.lua")
include("raycast.lua")


function _init()
	startInit()
	raycastInit()
	procgenInit()
	
	screenID = 0
end

function _update()
		local c_tbl =
	{
		[0] = initiateMaze,
		[1] = startScreen,
		[2] = menuSelect,
		[3] = movePlayer,
	}

	local func = c_tbl[screenID]
    
	if(func) then
		func()
	else

	end
end

function _draw()
	local c_tbl =
	{
		[0] = drawMaze,
		[1] = startScreenDraw,
		[2] = menuSelect,
		[3] = drawRoom,
	}

	local func = c_tbl[screenID]
    
	if(func) then
		func()
	else
	
	end
end
:: procgen.lua
--[[pod_format="raw",created="2025-10-23 22:33:23",modified="2025-10-25 02:02:00",revision=435,xstickers={}]]
-- CONTENT GENERATION
--[[
	Generate a map with walls at map edges + algorithmic maze generation 
	Map consists of tables of equal width within a larger table
	Root table maps Y coords while sub-tables map X coords and contain the values for walls / empty space
--]]

function procgenInit()
	---- These variables are customizable
	-- Width and height of the map in cells
	-- Even numbers are preferred
	-- Takes about 1 frame to initialize the map with 200 x 200 cells
	mapWidth = 30
	mapHeight = 30
	
	validCells = (mapWidth / 2) * (mapHeight / 2)
	finalizedCells = 0
	
	drawStage = 0
	drawSpeed = 2
	-- If drawMazeGen is true, then generation will be depicted visually
	-- This is much slower than if you opt not to draw the map generation 
	drawMazeGen = true
	-- slowGeneration
	slowGeneration = true
	-- drawCellStatus colors map cells based on whether or not they're finalized:
	  -- Dark blue = 
	drawCellStatus = true
	
	rainbow = userdata(u8, 7, 1)
	rainbow:set(0, 0, 8, 9, 10, 11, 12, 14)
	
	---- These variables are not customizable
	
	-- currentCoords is used to identify the position the algorithm is currently looking at
	currentCoords = {x = 0, y = 0,}
	-- Seed is the foundation for a completed map generation
	seed = 
	{
		["map"] = userdata(i16, mapWidth, mapHeight),
		["plot"] = userdata(i16, mapWidth, mapHeight),
		["ready"] = nil,
		["coords"] = currentCoords,
	}
	-- map
	mapPlot = userdata(i16, mapWidth, mapHeight)
end

function generateMap(_width, _height, _enemyCount, _goodiesCount, _difficulty, _tileset)
	-- Userdata with fixed width and height
	--TODO: Rewrite this since converting to userdata
	-- Nested table containing values for whether a given cell's state is finalized
	-- 0: Not plotted
	-- 1: Plotted but not finalized (surrounding cells have not been fully inspected yet)
	-- 2: Plotted and finalized
	_genMap = seed.map
	_plotted = seed.plot
	-- Value for current map coords

	------
	
	-- Set walls of map
	
	-- OPTIMIZATION
	_ends = repeatVar(2, _width)
	_midGens = repeatVar(1, _width - 2)
	_midPlots = repeatVar(0, _width - 2)
	if currentCoords.x <= _width then
		if currentCoords.x == 0 or currentCoords.x == _width then
			_genMap:set(currentCoords.x, 0, unpack(_ends))
			_plotted:set(currentCoords.x, 0, unpack(_ends))
		else
			_genMap:set(currentCoords.x, 0, 2, unpack(_midGens), 2)
			_plotted:set(currentCoords.x, 0, 2, unpack(_midPlots), 2)
		end
		
		genComplete = false
	else
		genComplete = true
	end
	
	currentCoords.x += 1
	
	--[[
	-- ALT
	-- Iterate through all Y positions
	for i = 1, _height do
		for j = 1, _width do
			if i == 1 or i == _height or j == 1 or j == _width then
				_genMap:set(i, j, 2)
				_plotted:set(i, j, 2)
			else
				_genMap:set(i, j, 1)
				_plotted:set(i, j, 0)
			end
		end
	end
	--]]
	
	--[[
	-- Set walls of map
	-- Iterate through all Y positions
	for i = 1, _height do
		-- Initialize Y axis table
		_genMap[i] = {}
		_plotted[i] = {}
		-- Iterate through all X positions on table
		for j = 1, _width do
			if(i == 1 or i == _height or j == 1 or j == _width) then
				_genMap[i][j] = 2
				_plotted[i][j] = 2
			else
				_genMap[i][j] = 1
				_plotted[i][j] = 0
			end
		end
	end
	
	--]]

	-- Ensure that starting cell (2, 2) is finalized as empty
	_genMap:set(2,2,0)
	_plotted:set(2,2,0)
	
	if genComplete == true then
		_ready = false
		currentCoords.x = 2
		currentCoords.y = 2
	else
		_ready = nil
	end
	
	_genSeed = {
		["map"] = _genMap,
		["plot"] = _plotted,
		["ready"] = _ready,
		["coords"] = currentCoords,
	}
	-- Trash code?
	--[[	
	while (_genSeed.ready == false) do
		_genSeed = stageMaze(_genSeed)
	end
	--]]
	
	return _genSeed
end

-- Root function for maze generation
function initiateMaze()
	if seed != nil then
		if seed.ready == nil then
			seed = generateMap(mapWidth, mapHeight, 0, 0, 0, 0)
			currentMap = seed.map
		else
			if seed.ready == false then
				seed = stageMaze(seed)
			else
				screenID = 1
			end
		end
	end
end

function stageMaze(_seed)
	_genProg = generateMaze(_seed)
	
	_seed.map = _genProg.map
	_seed.plot = _genProg.plot
	_seed.coords = _genProg.coords
	_seed.ready = _genProg.plotComplete
    
	currentMap = _seed.map
 	
	return _seed
end

function drawMaze()
	cls()
	if slowGeneration == true then
		if genComplete == false then
			-- Write loading message with timestamp in center of screen
			_str = "Initializing maze... %.2f"
			_str = string.format(_str, t())
			_strWidth = print(_str, 0, -1000)
			print(_str, 240 - _strWidth / 2, 130, 7)
			
			-- Draw loading bar
			rect(100, 140, 380, 148)
			rectfill(102, 142, 102 + 276 * (currentCoords.x / mapWidth), 146, rainbow:get(flr(t() * 8)%6, 0))
		else
			if drawMazeGen == true and seed != nil then
				drawMap()
			elseif drawMazeGen == false and seed != nil then
				-- Write loading screen message with timestamp in center of screen
				_str = "Generating maze... %.2f"
				_str = string.format(_str, t())
				_strWidth = print(_str, 0, -1000)
				print(_str, 240 - _strWidth / 2, 130, 7)
				
				-- Draw loading bar
				rect(100, 140, 380, 148)
				rectfill(102, 142, 102 + 276 * (finalizedCells / validCells), 146, rainbow:get(flr(t() * 8)%6, 0))
			else
				error("No seed")
			end
		end
	end
end

function generateMaze(_seed, _genMap, _plotted, _coords)
	_genMap = _seed.map
	_plotted = _seed.plot
	_coords = _seed.coords
	_genMap = _genMap
	
	_maxX = _genMap:width()
	_maxY = _genMap:height()
	_options = {}
	
	_genProg = {}
	
	_genProg.plotComplete = false
	
	-- Set current coords to 0
	_genMap:set(_coords.x, _coords.y, 0)
	
	-- List of all possible directions that lead the current cell to surrounding cells in cardinal directions
	_directions = 
	{
		{x = 2, y = 0, ix = 1, iy = 0,},
		{x = 0, y = 2, ix = 0, iy = 1,},
		{x = -2, y = 0, ix = -1, iy = 0,},
		{x = 0, y = -2, ix = 0, iy = -1,},
	}
	
	-- If current cell isn't finalized, then search surroundings for unexplored cell and move to it
	if (_plotted:get(_coords.x, _coords.y) < 2) then
		-- Check if neighboring cells are out-of-bounds and not yet explored; if not, then add them to list of potential options for dest cell
		for i = 1, 4 do
			if (_coords.x + _directions[i].x > 1 and _coords.x + _directions[i].x < _maxX and _coords.y + _directions[i].y > 1 and _coords.y + _directions[i].y < _maxY and _plotted:get(_coords.x + _directions[i].x, _coords.y + _directions[i].y) == 0) then
				_options[#_options + 1] = i
			end
		end
	
		-- If options list isn't empty...
		if (#_options > 0) then
			-- If there's more than one option (meaning current cell needs to be explored twice or more)...
			if (#_options > 1) then
				--  Set choice to any of the option tables at random
				_choice = _options[flr(rnd(#_options)) + 1]
				-- Plot current cell as explored
				_plotted:set(_coords.x, _coords.y, 1)
				-- Plot intersecting cell as explored
				_plotted:set(_coords.x + _directions[_choice].ix, _coords.y + _directions[_choice].iy, 1)
			-- Otherwise, if only one option is available...
			else
				-- Set choice to the only choice available
				_choice = _options[1]
				-- Document increase in amount of finalized cells
				finalizedCells += 1
				-- Plot current cell as finalized
				_plotted:set(_coords.x, _coords.y, 2)
				-- Plot intersecting cell as explored
				_plotted:set(_coords.x + _directions[_choice].ix, _coords.y + _directions[_choice].iy, 1)
			end
			-- Set intersecting square as empty space
			_genMap:set(_coords.x + _directions[_choice].ix, _coords.y + _directions[_choice].iy, 0)
			-- Set new coords
			_coords.x += _directions[_choice].x
			_coords.y += _directions[_choice].y
		else
			-- If options list is empty then mark the current cell as finalized
			_plotted:set(_coords.x, _coords.y, 2)
			-- Document increase in amount of finalized cells
			finalizedCells += 1
		end
	elseif (_plotted:get(_coords.x, _coords.y) == 2) then
		_options = {}
	
		-- Same as previous neighboring cell step, but look for any neighboring cell that isn't finalized, not just unexplored
		for i = 1, 4 do
			if (_coords.x + _directions[i].x > 1 and _coords.x + _directions[i].x < _maxX and _coords.y + _directions[i].y > 1 and _coords.y + _directions[i].y < _maxY and _plotted:get(_coords.x + _directions[i].x, _coords.y + _directions[i].y) < 2) then
				_options[#_options + 1] = i
			end
		end
	
		-- If there are free spaces to move to, then...
		if(#_options > 0) then
			if #_options > 1 then
				-- Select an available direction at random
				_choice = _options[flr(rnd(#_options)) + 1]
			else
				_choice = _options[1]
				-- Document increase in amount of finalized cells
				finalizedCells += 1
			end
			-- Set new coords
			_coords.x += _directions[_choice].x
			_coords.y += _directions[_choice].y
		else
			-- Check all cells for ANY cell that is explored but not finalized, and use that if it exists
			-- Otherwise maze generation is complete. Congratulations!
			_solved = true
			for i = 1, flr(_genMap:width() / 2) do
				for j = 1, flr(_genMap:height() / 2) do
					if (_plotted:get(i * 2, j * 2) == 1 and _solved == true) then
						_coords.x = i * 2
						_coords.y = j * 2
						_solved = false
					end
				end
			end
	
			if (_solved == true) then
				-- Done exploring! 
				_genProg.plotComplete = true
			end
		end
	end
	
	_genProg.map = _genMap
	_genProg.plot = _plotted
	_genProg.coords = _coords
		
	mapPlot = _plotted
	currentCoords.x = _coords.x
	currentCoords.y = _coords.y
	
	return _genProg
end

function checkCellValue(_map, _val, _x, _y, _ix, _iy)
	_ix = _ix != nil and _ix or 0
	_iy = _iy != nil and _iy or 0
	
	_trueVal = _map:get(_x + _ix, _y + _iy)
	
	if _trueVal == _val then
		return true
	else
		return false
	end
end

-- Build a table of the same variable repeated, then unpack and return it
function repeatVar(_value, _size)
	_t = {}
	for i = 1, _size do
		add(_t, _value)
	end
	
	return _t
end
:: raycast.lua
--[[pod_format="raw",created="2025-10-23 22:33:49",modified="2025-10-25 01:59:17",revision=162,xstickers={}]]
--Raycasting

function raycastInit()
	--Map width / height
	cellSize = 16
	h = 80
	
	-- Y position on screen where horizon starts
	horizon = 110

	
	
	--Player variables
	player =
	{
		xPos = cellSize * 2.5,
		yPos = cellSize * 2.5,
		xVel = 0,
		yVel = 0,
		zRot = 0,
		fov = 90,
	}
	
end

function raycast()
    -- For each X position
    for i = 0, 479 do
        -- Find starting tile
        px = player.xPos
        py = player.yPos

        x = player.xPos / cellSize
        y = player.yPos / cellSize

        pa = player.zRot / 360

			_xFOV = 480 / (player.fov / 360)
			_yFOV = 270 / ((player.fov / 2) / 360)

        -- Find ray direction (panoramic)
        vx = cos(pa - (i - 240) / _xFOV)
        vy = sin(pa - (i - 240) / _yFOV)

        -- Find standard distance
        dx = abs(1 / vx)
        dy = abs(1 / vy)

        -- Find increment value
        ix = vx > 0 and 1 or -1
        iy = vy > 0 and 1 or -1

        -- Find initial offset
        if (vx > 0) then
            ox = (flr(x) - x + 1) / vx
        else
            ox = abs((x - flr(x)) / vx)
        end

        if (vy > 0) then
            oy = (flr(y) - y + 1) / vy
        else
            oy = abs((y - flr(y)) / vy)
        end

        while true do
            -- Horizontal intersection
            if (abs(ox) < abs(oy)) then
                x += ix
                d = ox
                ox += dx
            -- Vertical intersection
            else
                y += iy
                d = oy
                oy += dy
            end
            if (d == nil or d == 0) then
                errorD(d)
            end

            -- Check for collision
            if (mapCollide(currentMap, flr(x), flr(y)) > 0 or x > currentMap:width() or y > currentMap:height() or x <= 0 or y <= 0) then
                _result = mapCollide(currentMap, flr(x), flr(y))
                if(_result != 7) then
                    line(i, horizon - h / d, i, horizon + h / d, _result)
                end
                break
            end
        end
    end
    printed = false
end

-- Get value from a map table - returns nil if out of range
function mapCollide(_mapVal, _x, _y)
    if (_x > 0 and _y > 0 and _x <= _mapVal:width() and _y <= _mapVal:height()) then
        return _mapVal:get(_x, _y)
    else
        return 7
    end
end

-- Detect if edge of objects will be collided with after moving
function mapObjectCollision(_map, _x, _y, _xDist, _yDist)
    _result = {}
    
    -- Get floor of player's X position
    _playerX = flr(_x)
    _playerY = flr(_y)

    -- Get floor of player's X position plus the provided offsets if player moves on X or Y axis
    _objX = flr(_x + _xDist)
    _objY = flr(_y + _yDist)
    
    -- If the player's offset X position and true Y position don't intersect with an occupied cell on the map...
    if (_objX > 0 and _objX < _map:width() and _playerY > 0 and _playerY < _map:height()) then
        -- ...Then check if the player's new X position intersects with an occupied cell on the map using a ternary statement
        -- If intersects, then mark as 0. If not, then mark as 1.
        _result[x] = _map:get(_objX, _playerY) > 0 and 0 or 1
    else
        _result[x] = 0
    end

    -- Same as above but for true X position and offset Y position
    if(_playerX > 0 and _playerX < _map:width() and _objY > 0 and _objY < _map:height()) then
        _result[y] = _map:get(_playerX, _objY) > 0 and 0 or 1
    else
        _result[y] = 0
    end

    -- Return table with X and Y values mapped to whether or not the new X / Y positions intersect with an occupied cell on the map
    return _result
end

-- Used by move() function to calculate if edge of map will be collided with after moving 
function mapEdgeCollision(_i, _dist, _maxDist)
    if(flr(_i + _dist) > 0 and flr(_i + _dist) <= _maxDist) then
        return _dist
    else
        return 0
    end
end

function move(_x, _y, _xDist, _yDist)
    _moveDist = {}
    _mapObjects = mapObjectCollision(currentMap, _x, _y, _xDist, _yDist)

    _moveDist[x] = _mapObjects[x] == 0 and 0 or mapEdgeCollision(_x, _xDist, currentMap:width())
    _moveDist[y] = _mapObjects[y] == 0 and 0 or mapEdgeCollision(_y, _yDist, currentMap:height())

    return _moveDist
end

-- Move player if arrows are pressed
function movePlayer()
    -- Rotate player
    if(btn(0)) then
        player.zRot += 2.5
    elseif(btn(1)) then
        player.zRot -= 2.5
    end

    -- Move player forward / backward, determining direction speed 
    if(btn(2)) then
        pa = player.zRot / 360
        player.xVel = cos(pa) / 2
        player.yVel = sin(pa) / 2
        
        _coords = move(player.xPos / cellSize, player.yPos / cellSize, player.xVel / cellSize, player.yVel / cellSize)

        player.xPos += _coords[x] * cellSize
        player.yPos += _coords[y] * cellSize

    elseif(btn(3)) then
        pa = player.zRot / 360
        player.xVel = cos(pa) / 2
        player.yVel = sin(pa) / 2

        _coords = move(player.xPos / cellSize, player.yPos / cellSize, -player.xVel / cellSize, -player.yVel / cellSize)
        
        player.xPos += _coords[x] * cellSize
        player.yPos += _coords[y] * cellSize
    end
end

-- Map functions
function drawMap()
	_mapWidth = 270 / seed.map:width()
	_mapHeight = 270 / seed.map:height()
	_xOffset = 240 - (seed.map:width() * _mapWidth) / 2
	_prevX = 0
	_prevY = 0

	for i = 1, seed.map:width() do
		for j = 1, seed.map:height() do
			if(mapPlot:get(i, j) != 0 and i != 1 and i != seed.map:width() and j != 1 and j != seed.map:height()) then
				rectfill(_prevX + _xOffset, _prevY, i * _mapWidth + _xOffset, j * _mapHeight, 12)
			end
			if drawCellStatus == true then
				if i == 1 or i == seed.map:width() or j == 1 or j == seed.map:height() then
					rectfill(_prevX + _xOffset, _prevY, i * _mapWidth + _xOffset, j * _mapHeight, 16)
				elseif seed.plot:get(i, j) == 2 then
					rectfill(_prevX + _xOffset, _prevY, i * _mapWidth + _xOffset, j * _mapHeight, 28)
				end
			end
				_prevY = j * _mapHeight + 1
        end
        _prevX = i * _mapWidth + 1
        _prevY = 0
    end

    -- rectfill(currentCoords.x * _mapWidth, currentCoords.y * _mapHeight, (currentCoords.x * _mapWidth) - _mapWidth, (currentCoords.y * _mapHeight) - _mapHeight, 9)

    -- circfill(((player.xPos / cellSize) - 1) * _mapWidth, ((player.yPos / cellSize) - 1) * _mapHeight, 1, 7)
end

function drawRoom()
    cls(0)
    rectfill(0,0,480,horizon,7)
    raycast()
end
:: start.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMC0yMyAyMjozNTozOSIsbW9k
aWZpZWQ9IjIwMjUtMTAtMjQgMDc6NDE6MTEiLHJldmlzaW9uPTg4LHhzdGlja2Vycz17fV1dCmZ1
bmN0aW9uIHN0YXJ0SW5pdCgpCglwdXBpbFRydWVYID0gNDgqMwoJcHVwaWxUcnVlWSA9IDMxKjMK
CXB1cGlsWCA9IHB1cGlsVHJ1ZVgKCXB1cGlsWSA9IHB1cGlsVHJ1ZVkKCWJyb3dUcnVlWCA9IDI0
KjMKCWJyb3dUcnVlWSA9IDMqMwoJYnJvd1ggPSBicm93VHJ1ZVgKCWJyb3dZID0gYnJvd1RydWVZ
CgkKCS0tT2Zmc2V0IGZvciBmYWNpYWwgZmVhdHVyZXMKCXhPZmZzZXQgPSAwCgl5T2Zmc2V0ID0g
MAoJek9mZnNldCA9IDE2CglvZmZzZXRDb3VudGVyID0gMAoJZXNjYXBlQ291bnRlciA9IDAKCS0t
T2Zmc2V0IG1vZGUgMTogSWRseSBib2JibGUKCS0tT2Zmc2V0IG1vZGUgMjogUnVzaCBvZmZzY3Jl
ZW4gdG8gdGhlIGxlZnQKCW1vZGUgPSAxCgkKCS0tQW5pbWF0aW9ucyBmb3Igc3RhcnQgc2NyZWVu
CglhbmltQ291bnQgPSAwCglhbmltQ291bnQxID0gMAplbmQKCmZ1bmN0aW9uIHN0YXJ0U2NyZWVu
KCkKCW9mZnNldFVwZGF0ZSgpCmVuZAoKZnVuY3Rpb24gc3RhcnRTY3JlZW5EcmF3KCkKCWlkbGVB
bmltKCkKZW5kCgpmdW5jdGlvbiBpZGxlQW5pbSgpCglwYWx0KDE0LCB0cnVlKQoJcGFsdCgwLCBm
YWxzZSkKICAgIAogICAgY2xzKDEpCgogICAgLS1CYWNrZ3JvdW5kOiBmaXNoeSBibHVlCiAgICBy
ZWN0ZmlsbCgwLDAsNDc5LDI2OSw3KQoKICAgIC0tRHJhdyBjaXJjbGUgaGVhZAogICAgY2lyY2Zp
bGwoMCArIHhPZmZzZXQsMTAwICsgeU9mZnNldCw2MDAsMTIpCiAgICAKICAgIC0tRHJhdyB0ZXh0
CiAgICBwcmludFhPZmZzZXQgPSB4T2Zmc2V0IC8gMwogICAgcHJpbnRZT2Zmc2V0ID0geU9mZnNl
dCAvIDMKICAgIHByaW50KCJmcHMiLDIyOCArIHByaW50WE9mZnNldCwyMTUgKyBwcmludFlPZmZz
ZXQsNykKICAgIHByaW50KCIoZmlzaCBwZXJzb24gc2hvb3RlcikiLDE4NSArIHByaW50WE9mZnNl
dCwyMzAgKyBwcmludFlPZmZzZXQsNykKICAgIHByaW50KCJwcmVzcyCXIHRvIHN0YXJ0IiwxOTUg
KyBwcmludFhPZmZzZXQsMjQ1ICsgcHJpbnRZT2Zmc2V0LDcpCgogICAgLS1EcmF3IGV5ZWxhc2gK
ICAgIHNzcHIoNywwLDAsODYsNTgsMTExICsgeE9mZnNldCwzMCArIHlPZmZzZXQsODYqMyw1OCoz
KQogICAgLS1EcmF3IGZhY2UgbWFya2luZwogICAgc3Nwcig2LDAsMCwyMywyMSwyNTUgKyB4T2Zm
c2V0LDE1OSArIHlPZmZzZXQsMjMqMywyMSozKQogICAgLS1EcmF3IGFuZCBhbmltYXRlIHB1cGls
IC8gaXJpcyBhbmQgZXllYnJvdwogICAgYnJvd0FuaW1hdGUoKQogICAgcHVwaWxBbmltYXRlKCkK
ZW5kCgoKLS0gQU5JTUFUSU9OUwotLXNpbiBmdW5jdGlvbiBmb3IgdHdlZW4gZnJhbWVzCmZ1bmN0
aW9uIHNpblR3ZWVuKGZybSwgc3BlZWRNdWx0LCBzdGFydCwgbGVuZ3RoKQogICAgc3BlZWQgPSA4
ICogc3BlZWRNdWx0CiAgICAKICAgIHggPSBmcm0gLyBzcGVlZAoKICAgIC0td2hlbiBjYWxjdWxh
dGluZyBzaW4sIDAuMjUgaXMgLTEgYW5kIC0uNzUgaXMgMQogICAgcmV0dXJuIDEgKyBzaW4oc3Rh
cnQgKyAoKHgpICogbGVuZ3RoKSkKZW5kCgotLUJvYmJsZSBhbmltYXRpb24gdmFsdWUgLSBnaXZl
IHNwZWVkIGFuZCBkaXN0ICh0cnkgNiAvIDIpCi0tIGluaXRQb3M6IEluaXRpYWwgcG9zaXRpb24g
b2Ygb2JqZWN0Ci0tIGZyYW1lOiBmcmFtZSBjb3VudGVyIHVzZWQgd2hlbiBjYWxsaW5nIHRoaXMg
b2JqZWN0Ci0tIHNwZWVkOiBlZmZlY3RpdmVseSB0aGUgIm1heCBmcmFtZSIsIGRpdmlkZWQgYnkg
ZnJhbWUgdG8gZ2V0IGFjdHVhbCBzcGVlZAotLSBkaXN0OiBtdWx0aXBsaWVyIGZvciBzaW5Ud2Vl
biByZXN1bHRzCi0tIHN0YXJ0OiBzdGFydCBvZiBzaW5lIHdhdmUKLS0gICAwIC8gMC41OiBtaWQt
c3dpbmcKLS0gICAwLjI1IC8gMC43NTogc3RhcnQgYXQgc2xvdyBwb3J0aW9uIG9mIHN3aW5nCi0t
IGxlbmd0aDogRGVzaXJlZCBsZW5ndGggb2Ygc2luZSB3YXZlCi0tICAgMTogZnVsbCBzaW5lIHdh
dmUKLS0gICAwLjU6IGhhbGYgYSBzaW5lIHdhdmUKLS0gICB0YWtlcyBhbnkgbnVtYmVyIGZyb20g
CmZ1bmN0aW9uIGJvYmJsZShpbml0UG9zLCBmcmFtZSwgc3BlZWQsIGRpc3QsIHN0YXJ0LCBsZW5n
dGgpCiAgICB4ID0gc2luVHdlZW4oZnJhbWUsIHNwZWVkLCBzdGFydCwgbGVuZ3RoKSAqIGRpc3QK
ICAgIHJldHVybiBpbml0UG9zICsgeAplbmQKCmZ1bmN0aW9uIG9mZnNldFVwZGF0ZSgpCiAgICAt
LU1vZGUgMSA9IHN0YXJ0IHNjcmVlbgogICAgaWYobW9kZSA9PSAxKSB0aGVuCiAgICAgICAgb2Zm
c2V0Q291bnRlciArPSAxCiAgICAgICAgLS1ib2JibGUoKSBpcyBhbiBhbmltYXRpb24gdGhhdCB3
aWxsIHdvYmJsZSBhIHZhcmlhYmxlIG9uIGEgc2luZSB3YXZlCiAgICAgICAgeE9mZnNldCA9IGJv
YmJsZSgwLCBvZmZzZXRDb3VudGVyLzIsIDksIDUsIDAuMjUsIDAuNSkgLSA2CiAgICAgICAgeU9m
ZnNldCA9IGJvYmJsZSgwLCBvZmZzZXRDb3VudGVyLzIsIDE0LCA1LCAwLjI1LCAwLjUpIC0gNgoK
ICAgICAgICAtLUlmIFggaXMgcHJlc3NlZC4uLgogICAgICAgIGlmKGJ0big1KSkgdGhlbgogICAg
ICAgICAgICAtLS4uLlRoZW4gY2hhbmdlIG1vZGUgdG8gMgogICAgICAgICAgICBtb2RlID0gMgog
ICAgICAgIGVuZAogICAgLS1Nb2RlIDIgPSB0cmFuc2l0aW9uaW5nIHRvIGludHJvIHNjcmVlbgog
ICAgZWxzZWlmKG1vZGUgPT0gMikgdGhlbgogICAgICAgIC0tU2hpZnQgdGhlIGhlYWQgYW5kIG90
aGVyIHRpdGxlIHNjcmVlbiBlbGVtZW50cyBvZmZzY3JlZW4gCiAgICAgICAgZXNjYXBlQ291bnRl
ciArPSAyCgogICAgICAgIHhPZmZzZXQgLT0gZXNjYXBlQ291bnRlcgogICAgICAgIHpPZmZzZXQg
LT0gMC4yNQoKICAgICAgICAtLVJlc2V0IGdlbmVyYWwtdXNlIHZhcmlhYmxlcyB0aGF0IGRvbid0
IG5lZWQgcHJlc2VydmVkIHZhbHVlcyBhbmQgcHJvY2VlZCB0byB0aGUgaW50cm8KICAgICAgICBp
Zihlc2NhcGVDb3VudGVyID4gNDgqMikgdGhlbgogICAgICAgICAgICB5T2Zmc2V0ID0gMAogICAg
ICAgICAgICBlc2NhcGVDb3VudGVyID0gMAogICAgICAgICAgICBvZmZzZXRDb3VudGVyID0gMAog
ICAgICAgICAgICBhbmltQ291bnQgPSAwCiAgICAgICAgICAgIGFuaW1Db3VudDEgPSAwCiAgICAg
ICAgICAgIHNjcmVlbklEID0gMgogICAgICAgICAgICBtb2RlID0gMQogICAgICAgIGVuZAogICAg
ZW5kCmVuZAoKLS1Ccm93IHR3aXRjaApmdW5jdGlvbiBicm93QW5pbWF0ZSgpCiAgICBpZihhbmlt
Q291bnQgPCA0OCoyKSB0aGVuCiAgICAgICAgYnJvd1ggPSBib2JibGUoYnJvd1RydWVYLCBhbmlt
Q291bnQsIDYsIC0xLCAwLjI1LCAwLjc1KQogICAgICAgIGJyb3dZID0gYm9iYmxlKGJyb3dUcnVl
WSwgYW5pbUNvdW50LCA2LCAyLCAwLjI1LCAwLjc1KQoKICAgICAgICBhbmltQ291bnQgKz0gMQog
ICAgLS0gVXNlIFJORyB0byBkZXRlcm1pbmUgaWYgYnJvdyBzaG91bGQgYmUgdHdpdGNoaW5nCiAg
ICBlbHNlaWYoZmxyKHJuZCgxMDApKSA9PSAxKSB0aGVuCiAgICAgICAgYW5pbUNvdW50ID0gMAog
ICAgZW5kCgogICAgc3Nwcig1LDAsMCwzMiwxNCxicm93WCArIHhPZmZzZXQsYnJvd1kgKyB5T2Zm
c2V0LDMyKjMsMTQqMykKZW5kCgotLVB1cGlsIHdpZ2dsZQpmdW5jdGlvbiBwdXBpbEFuaW1hdGUo
KQogICAgLS0gQW5pbWF0ZSBwdXBpbCBmb3IgMzYgZnJhbWVzLCB0aGVuIGRvbid0IGFuaW1hdGUg
Zm9yIDEyIGZyYW1lcywgdGhlbiBzdGFydCBhZ2FpbgogICAgaWYoYW5pbUNvdW50MSA8IDM2KjIp
IHRoZW4KICAgICAgICBwdXBpbFggPSBib2JibGUocHVwaWxUcnVlWCwgYW5pbUNvdW50MSwgMS41
LCAxLCAwLjI1LCAwLjc1KQogICAgZWxzZWlmKGFuaW1Db3VudDEgPj0gNDgqMikgdGhlbgogICAg
ICAgIGFuaW1Db3VudDEgPSAwCiAgICBlbmQKCiAgICBhbmltQ291bnQxICs9IDEKCiAgICBzc3By
KDQsMCwwLDQyLDI5LHB1cGlsWCArIHhPZmZzZXQscHVwaWxZICsgeU9mZnNldCw0MiozLDI5KjMp
CmVuZA==
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTEyIDE0OjQ5OjMwIixtb2RpZmllZD0iMjAyNS0x
MC0yNSAwMjowMjoxMCIscnVudGltZT0yMCx3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzEyLDE0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJwcm9jZ2VuLmx1YSMyMywyMCIs
d29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iaW50cm8ubHVhIzUxLDY0Iix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJzdGFydC5sdWEjODYsMSIsd29ya3NwYWNlX2luZGV4PTF9LHts
b2NhdGlvbj0icmF5Y2FzdC5sdWEjMTkyLDEyIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9u
PSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249ImdmeC9maXhlZC5nZngi
LHdvcmtzcGFjZV9pbmRleD0yfX1dXQ==
:: [eoc]
